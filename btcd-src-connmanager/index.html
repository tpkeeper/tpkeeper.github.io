<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1">
    <title>btcd 源码分析系列：3 - connmanager - 大远的博客</title>

    <style type="text/css">
        img.wp-smiley,
        img.emoji {
            display: inline !important;
            border: none !important;
            box-shadow: none !important;
            height: 1em !important;
            width: 1em !important;
            margin: 0 .07em !important;
            vertical-align: -0.1em !important;
            background: none !important;
            padding: 0 !important;
        }
    </style>
    <link rel='stylesheet' href='https://tpkeeper.github.io/css/style.css' type='text/css' media='all' />
    <link rel='stylesheet' href='https://tpkeeper.github.io/css/custom.css' type='text/css' media='all' />
        
</head>
    <body class="two-column">
        <a href="#content">Skip to content</a>
<div class="wrapper">
    <header role="banner" class="banner widgets columns-1">
        <a href="/" rel="home">
            <h1 class="site">大远的博客</h1>
            <p></p>
        </a>
        <nav role="navigation" aria-label="Primary Navigation">

            <ul class="menu">
                <li class="menu-item "><a class="menu__link" href="/about/">关于</a></li>
            </ul>
            <select onChange="location.href=value;">
                <option value="/about/" class="menu-item menu-item-type-custom menu-item-object-custom" >关于</option>
            </select>
        </nav>
    </header>

    <br>
    <div style="width: 100%; max-height: 100px; text-align: center;">
       
</div>

    <div class="breadcrumbs">
        
    </div>
        <div id="content" class="content">

<main role="main">
    <article role="article" class="post type-post format-standard hentry">
        <header class="post-header">
            <h1>btcd 源码分析系列：3 - connmanager</h1>
            <div class="post-details">
                <a rel="bookmark">
                    <time datetime="2019-08-30T830:53:476">2019-08-30</time>
                </a>
				
<span style="float: right;">
    <div id="fb-root" style="height: 100%;"></div>
    
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.2"></script>
    
    <div class="fb-share-button" data-href="https://tpkeeper.github.io/btcd-src-connmanager/" data-layout="button_count" data-size="small">
        <a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ftpkeeper.github.io%2fbtcd-src-connmanager%2f" class="fb-xfbml-parse-ignore">Share</a>
    </div>
    &nbsp;
    <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-text="btcd 源码分析系列：3 - connmanager" data-url="https://tpkeeper.github.io/btcd-src-connmanager/" data-show-count="false">Tweet</a>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    &nbsp;
    
</span>

            </div>
        </header>

        <div class="post-content">
            

<blockquote>
<p>参考：<a href="https://github.com/btcsuite/btcd/tree/master/connmgr">btcd</a></p>
</blockquote>

<ul>
<li>connmanamger 负责节点的连接处理，包括监听来自其他节点的连接请求和主动向其他节点发起连接请求，并将获取到的连接对象conn交给回调函数处理，实际上这些回调函数是由server实现的，它们会根据conn生成对应的peer，交由peer处理之后的逻辑</li>
<li>默认outbound peer数量为8</li>
<li>节点发现

<ul>
<li>address database （第一次启动时为空）</li>
<li>-addnode -connect (手动)</li>
<li>dns seed （通过dns获取addr）</li>
<li>hard-coded seeds（代码中的seed）</li>
<li>getaddr from other peers （通过其他节点同步）</li>
</ul></li>
</ul>

<h2 id="一-创建connmanager对象">一、创建connmanager对象</h2>

<ul>
<li>主要是根据传入的config结构体参数返回一个指针，config结构体主要 包含一些回调方法和[]listener,这样便于灵活实现和调用</li>
</ul>

<pre><code class="language-go">// New returns a new connection manager.
// Use Start to start connecting to the network.
func New(cfg *Config) (*ConnManager, error) {
	if cfg.Dial == nil {
		return nil, ErrDialNil
	}
	// Default to sane values
	if cfg.RetryDuration &lt;= 0 {
		cfg.RetryDuration = defaultRetryDuration
	}
	if cfg.TargetOutbound == 0 {
		cfg.TargetOutbound = defaultTargetOutbound
	}
	cm := ConnManager{
		cfg:      *cfg, // Copy so caller can't mutate
		requests: make(chan interface{}),
		quit:     make(chan struct{}),
	}
	return &amp;cm, nil
}


// Config holds the configuration options related to the connection manager.
type Config struct {
	// Listeners defines a slice of listeners for which the connection
	// manager will take ownership of and accept connections.  When a
	// connection is accepted, the OnAccept handler will be invoked with the
	// connection.  Since the connection manager takes ownership of these
	// listeners, they will be closed when the connection manager is
	// stopped.
	//
	// This field will not have any effect if the OnAccept field is not
	// also specified.  It may be nil if the caller does not wish to listen
	// for incoming connections.
	Listeners []net.Listener

	// OnAccept is a callback that is fired when an inbound connection is
	// accepted.  It is the caller's responsibility to close the connection.
	// Failure to close the connection will result in the connection manager
	// believing the connection is still active and thus have undesirable
	// side effects such as still counting toward maximum connection limits.
	//
	// This field will not have any effect if the Listeners field is not
	// also specified since there couldn't possibly be any accepted
	// connections in that case.
	OnAccept func(net.Conn)

	// TargetOutbound is the number of outbound network connections to
	// maintain. Defaults to 8.
	TargetOutbound uint32

	// RetryDuration is the duration to wait before retrying connection
	// requests. Defaults to 5s.
	RetryDuration time.Duration

	// OnConnection is a callback that is fired when a new outbound
	// connection is established.
	OnConnection func(*ConnReq, net.Conn)

	// OnDisconnection is a callback that is fired when an outbound
	// connection is disconnected.
	OnDisconnection func(*ConnReq)

	// GetNewAddress is a way to get an address to make a network connection
	// to.  If nil, no new connections will be made automatically.
	GetNewAddress func() (net.Addr, error)

	// Dial connects to the address on the named network. It cannot be nil.
	Dial func(net.Addr) (net.Conn, error)
}
</code></pre>

<pre><code class="language-go">cmgr, err := connmgr.New(&amp;connmgr.Config{
		Listeners:      listeners,
		OnAccept:       s.inboundPeerConnected,
		RetryDuration:  connectionRetryInterval,
		TargetOutbound: uint32(targetOutbound),
		Dial:           hcdDial,
		OnConnection:   s.outboundPeerConnected,
		GetNewAddress:  newAddressFunc,
	})
</code></pre>

<h2 id="二-start">二、start</h2>

<ul>
<li>启动connhandler 处理connrequest请求结果，即处理主动向其他节点发起请求的结果</li>
<li>启动listenhandler 监听来自其他节点的连接</li>
<li>connrequest 向其他节点发起连接
```go
// Start launches the connection manager and begins connecting to the network.
func (cm *ConnManager) Start() {
	// Already started?
	if atomic.AddInt32(&amp;cm.start, 1) != 1 {
		return
	}</li>
</ul>

<p>	log.Trace(&ldquo;Connection manager started&rdquo;)
	cm.wg.Add(1)
	go cm.connHandler()</p>

<p>	// Start all the listeners so long as the caller requested them and
	// provided a callback to be invoked when connections are accepted.
	if cm.cfg.OnAccept != nil {
		for _, listner := range cm.cfg.Listeners {
			cm.wg.Add(1)
			go cm.listenHandler(listner)
		}
	}</p>

<p>	for i := atomic.LoadUint64(&amp;cm.connReqCount); i &lt; uint64(cm.cfg.TargetOutbound); i++ {
		go cm.NewConnReq()
	}
}</p>

<pre><code>
## 三、对监听到的连接的处理

* 当有新的连接请求，会将此连接对象直接交给回调函数onAccept()处理，该函数的具体实现是在server中s.inboundPeerConnected()方法
* s.inboundPeerConnected() 会创建一个inbound peer，并进入peer的处理逻辑

```go
// listenHandler accepts incoming connections on a given listener.  It must be
// run as a goroutine.
func (cm *ConnManager) listenHandler(listener net.Listener) {
	log.Infof(&quot;Server listening on %s&quot;, listener.Addr())
	for atomic.LoadInt32(&amp;cm.stop) == 0 {
		conn, err := listener.Accept()
		if err != nil {
			// Only log the error if not forcibly shutting down.
			if atomic.LoadInt32(&amp;cm.stop) == 0 {
				log.Errorf(&quot;Can't accept connection: %v&quot;, err)
			}
			continue
		}
		go cm.cfg.OnAccept(conn)
	}

	cm.wg.Done()
	log.Tracef(&quot;Listener handler done for %s&quot;, listener.Addr())
}
</code></pre>

<p>onaccept的具体实现</p>

<pre><code class="language-go">// inboundPeerConnected is invoked by the connection manager when a new inbound
// connection is established.  It initializes a new inbound server peer
// instance, associates it with the connection, and starts a goroutine to wait
// for disconnection.
func (s *server) inboundPeerConnected(conn net.Conn) {
	sp := newServerPeer(s, false)
	sp.isWhitelisted = isWhitelisted(conn.RemoteAddr())
	sp.Peer = peer.NewInboundPeer(newPeerConfig(sp))
	sp.AssociateConnection(conn)
	go s.peerDoneHandler(sp)
}
</code></pre>

<h2 id="四-对主动发起的连接的处理">四、对主动发起的连接的处理</h2>

<ul>
<li>生成一个新的请求id</li>
<li>然后将请求的结果统一发给connhandler处理</li>
<li>connhandler 根据不同的结果分别做不同的处理

<ul>
<li>如果成功则调用OnConnection回调函数，该函数由server的s.outboundPeerConnected（）实现</li>
<li>如果请求失败则调用自身的handleFailedConn()函数，尝试再次请求等逻辑</li>
</ul></li>

<li><p>s.outboundPeerConnected 同样是先创建一个outbound peer，然后进入peer的处理逻辑</p>

<pre><code class="language-go">// Connect assigns an id and dials a connection to the address of the
// connection request.
func (cm *ConnManager) Connect(c *ConnReq) {
	if atomic.LoadInt32(&amp;cm.stop) != 0 {
		return
	}
	if atomic.LoadUint64(&amp;c.id) == 0 {
		atomic.StoreUint64(&amp;c.id, atomic.AddUint64(&amp;cm.connReqCount, 1))
	}
	log.Debugf(&quot;Attempting to connect to %v&quot;, c)
	conn, err := cm.cfg.Dial(c.Addr)
	if err != nil {
		cm.requests &lt;- handleFailed{c, err}
	} else {
		cm.requests &lt;- handleConnected{c, conn}
	}
}
</code></pre>

<pre><code class="language-go">// connHandler handles all connection related requests.  It must be run as a
// goroutine.
//
// The connection handler makes sure that we maintain a pool of active outbound
// connections so that we remain connected to the network.  Connection requests
// are processed and mapped by their assigned ids.
func (cm *ConnManager) connHandler() {
	conns := make(map[uint64]*ConnReq, cm.cfg.TargetOutbound)
out:
	for {
		select {
		case req := &lt;-cm.requests:
			switch msg := req.(type) {

			case handleConnected:
				connReq := msg.c
				connReq.updateState(ConnEstablished)
				connReq.conn = msg.conn
				conns[connReq.id] = connReq
				log.Debugf(&quot;Connected to %v&quot;, connReq)
				connReq.retryCount = 0
				cm.failedAttempts = 0

				if cm.cfg.OnConnection != nil {
					go cm.cfg.OnConnection(connReq, msg.conn)
				}

			case handleDisconnected:
				if connReq, ok := conns[msg.id]; ok {
					connReq.updateState(ConnDisconnected)
					if connReq.conn != nil {
						connReq.conn.Close()
					}
					log.Debugf(&quot;Disconnected from %v&quot;, connReq)
					delete(conns, msg.id)

					if cm.cfg.OnDisconnection != nil {
						go cm.cfg.OnDisconnection(connReq)
					}

					if uint32(len(conns)) &lt; cm.cfg.TargetOutbound &amp;&amp; msg.retry {
						cm.handleFailedConn(connReq)
					}
				} else {
					log.Errorf(&quot;Unknown connection: %d&quot;, msg.id)
				}

			case handleFailed:
				connReq := msg.c
				connReq.updateState(ConnFailed)
				log.Debugf(&quot;Failed to connect to %v: %v&quot;, connReq, msg.err)
				cm.handleFailedConn(connReq)
			}

		case &lt;-cm.quit:
			break out
		}
	}

	cm.wg.Done()
	log.Trace(&quot;Connection handler done&quot;)
}

</code></pre></li>
</ul>

<p>OnConnection的具体实现</p>

<pre><code class="language-go">// outboundPeerConnected is invoked by the connection manager when a new
// outbound connection is established.  It initializes a new outbound server
// peer instance, associates it with the relevant state such as the connection
// request instance and the connection itself, and finally notifies the address
// manager of the attempt.
func (s *server) outboundPeerConnected(c *connmgr.ConnReq, conn net.Conn) {
	sp := newServerPeer(s, c.Permanent)
	p, err := peer.NewOutboundPeer(newPeerConfig(sp), c.Addr.String())
	if err != nil {
		srvrLog.Debugf(&quot;Cannot create outbound peer %s: %v&quot;, c.Addr, err)
		s.connManager.Disconnect(c.ID())
	}
	sp.Peer = p
	sp.connReq = c
	sp.isWhitelisted = isWhitelisted(conn.RemoteAddr())
	sp.AssociateConnection(conn)
	go s.peerDoneHandler(sp)
	s.addrManager.Attempt(sp.NA())
}
</code></pre>

<p>a -&gt; b a向b节点发起连接</p>

<p>b：
某场景下触发了ban()和disconnect()，b会在banduration（默认24小时）之内，不允许a连接（onVersion里 最后调用addpeer()时判断，然后断掉连接）</p>

<p>a:在被b ban了之后，peer.start()会失败（在协商version时被b断开），接着调用disconnect()</p>

<p>server作为枢纽，处理connmanager和peer之间的协作</p>

        </div>

        <footer class="post-footer">
            
            <span class="post-categories">
                
                <a href="https://tpkeeper.github.io/categories/btcd-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="tag">btcd 源码分析</a>
                
            </span>
            

            
            <span class="post-tags">
                
                <a href="https://tpkeeper.github.io/tags/btcd" rel="tag">btcd</a>&emsp;
                
            </span>
            
        </footer>
        
<table cellspacing="15" style="width:100%; border: none;">
    <tr>
        <td style="text-align: center; border: none; padding: 0px;">
        </td>
        <td style="text-align: center; border: none; padding: 0px;">
        </td>
    </tr>
</table>

        
	
	
	<h4>Related Posts</h4>
	<ol style="margin-left: 30px; list-style-type: decimal;">
		
		<li><strong><a href="/btcd-src-addrmanager/">btcd 源码分析系列：2 - addrmanager</a></strong></li>
		
		<li><strong><a href="/btcd-src-start/">btcd 源码分析系列 - 1 - 启动分析</a></strong></li>
		
	</ol>
	

    </article>

    
    <nav class="navigation post-navigation" role="navigation">
        <div class="nav-links">
            <div class="nav-previous">
                
                <a class="previous" href="https://tpkeeper.github.io/btcd-src-addrmanager/"> btcd 源码分析系列：2 - addrmanager</a>
                
            </div>
            <div class="nav-next">
                
                <a class="next" href="https://tpkeeper.github.io/btcd-src-peer/"> btcd 源码分析系列：4 - p2p网络的peer</a>
                
            </div>
        </div>
    </nav>
    <section>
        
    </section>
    

</main>


        <div class="sidebar1 widgets columns-1">

    <aside>
    
</aside>
    <aside class="widget widget_categories">
        <h2>Categories</h2>
        <ul class="widget__list"><li class="cat-item cat-item-2">
                <a href="/categories/btcd-%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90">btcd 源码分析 (7)</a>
            </li><li class="cat-item cat-item-2">
                <a href="/categories/hd-wallet-%e7%b3%bb%e5%88%97">HD Wallet 系列 (1)</a>
            </li>
        </ul>
    </aside>

    <aside class="widget widget_tag_cloud">
        <h2>Tags</h2>
        <div class="tagcloud"><a class="tag-cloud-link" href="/tags/btcd" title="btcd" style="font-size: 12pt;">btcd</a>&emsp;<a class="tag-cloud-link" href="/tags/hd-wallet" title="hd-wallet" style="font-size: 12pt;">HD Wallet</a>&emsp;
        </div>
    </aside>

    <aside class="widget widget_recent_entries">
        <h2>Recent Posts</h2>
        <ul>
            <li>
                <a href="/hd-wallet-overview/">HD Wallet 系列：概述</a>
            </li>
            <li>
                <a href="/btcd-src-rpc/">btcd 源码分析系列：7 - rpc</a>
            </li>
            <li>
                <a href="/btcd-src-mempool/">btcd 源码分析系列：6 - mempool</a>
            </li>
            <li>
                <a href="/btcd-src-wire/">btcd源码分析系列：5 - p2p网络的消息协议</a>
            </li>
            <li>
                <a href="/btcd-src-peer/">btcd 源码分析系列：4 - p2p网络的peer</a>
            </li>
            <li>
                <a href="/btcd-src-connmanager/">btcd 源码分析系列：3 - connmanager</a>
            </li>
            <li>
                <a href="/btcd-src-addrmanager/">btcd 源码分析系列：2 - addrmanager</a>
            </li>
            <li>
                <a href="/btcd-src-start/">btcd 源码分析系列 - 1 - 启动分析</a>
            </li>
        </ul>
    </aside>

    <aside class="widget widget_archive">
        <h2>Archives</h2>
        <ul>
        </ul>
    </aside>

</div>
        </div>
        </div>
<footer role="contentinfo" class="document-footer contentinfo widgets columns-1">

    <aside class="widget widget_text">
        <div class="textwidget">
            <p>© 大远的博客 / Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/tosi29/inkblotty" target="_blank">Inkblotty</a></p>
        </div>
    </aside>
</footer>
</div>

    </body>
</html>
