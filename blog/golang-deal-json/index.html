<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.71.0-DEV" />


<title>Golang 中的 json 处理 - 大远的博客</title>
<meta property="og:title" content="Golang 中的 json 处理 - 大远的博客">


  <link href='http://www.tpkeep.com/favicon.jpg' rel='icon' type='image/x-icon'/>



  










<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/%3cnil%3e"
         width=""
         height=""
         alt="">
  </a>

  <ul class="nav-links">
    
    <li><a href="/">首页</a></li>
    
    <li><a href="/post">归档</a></li>
    
    <li><a href="/tags">标签</a></li>
    
    <li><a href="/categories">分类</a></li>
    
    <li><a href="/about">关于</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">3 min read</span>
    

    <h1 class="article-title">Golang 中的 json 处理</h1>

    
    <span class="article-date">2019-12-25</span>
    

    <div class="article-content">
      <h2 id="介绍">介绍</h2>
<p>JSON 是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析与生成。其采用的是独立于语言的文本格式。可以去官网 <a href="https://json.org">json.org</a> 详细了解。</p>
<p>JSON 中有两种结构，键值对的对象和数组，在 Golang 中对应的结构是struct/map 和 slice。JSON 中的基本类型是 string、number、bool、nul，在 Golang 中对应的就是 string、float64、boolean、nil。</p>
<h2 id="编码">编码</h2>
<p>我们可以使用 Marshal 方法来实现 JSON 编码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})([]<span style="color:#66d9ef">byte</span>,<span style="color:#66d9ef">error</span>)
</code></pre></div><p>我们定义一个 People 的结构体：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">People</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
    <span style="color:#a6e22e">Age</span> <span style="color:#66d9ef">int</span>
}
</code></pre></div><p>并且实例化：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">People</span>{
    <span style="color:#e6db74">&#34;bob&#34;</span>,
    <span style="color:#ae81ff">21</span>
}
</code></pre></div><p>然后我们就可以使用 json.Marshal 来得到一个该实例的 JSON 编码格式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">b</span>,<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Marshal</span>(<span style="color:#a6e22e">p</span>)
</code></pre></div><p>b 就是包含 JSON 数据的字节序列，等价于下边的结果：</p>
<pre><code>[]byte(`{&quot;Name&quot;:&quot;bob&quot;,&quot;Age&quot;:21}`)
</code></pre><p>但是需要注意，并不是结构体中的所有字段都可以编码为 JSON 格式：</p>
<ul>
<li>JSON 只支持 string 作为键，所以 map 中的 key，必须为 string 类型</li>
<li>通道、附属、方法等类型不能被编码</li>
<li>指针类型会对它指向的数据进行编码，如果是 nil，则编码为 null</li>
<li>json 包只能获取结构体中导出的字段，因此未导出字段不能被编码</li>
</ul>
<h2 id="解码">解码</h2>
<p>我们可以使用 Unmarshal 方法来解码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">data</span> []<span style="color:#66d9ef">byte</span>,<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">error</span>
</code></pre></div><p>我们必须先创建一个变量来存放我们解码之后的数据：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#a6e22e">People</span>
</code></pre></div><p>然后调用 json.Unmarshal，并传入一个 JSON 格式的字节序列 和一个指向 p 的指针：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">b</span>,<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p</span>)
</code></pre></div><p>解码之后，p 中就会存放解码之后的数据，等价于下面的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">People</span>{
    <span style="color:#e6db74">&#34;bob&#34;</span>,
    <span style="color:#ae81ff">21</span>
}
</code></pre></div><p>那 Unmarshal 方法是如何将 JSON 数据中的键跟结构体中的字段一个一个对应起来的呢？我们用 &ldquo;Name&rdquo; 这个字段来说明，Unmarshal 会遍历目标结构体的字段，依次按下列顺序优先匹配：</p>
<ul>
<li>导出字段的 Tag 包含 &ldquo;Name&quot;的</li>
<li>导出字段的名字是 &ldquo;Name&rdquo; 的</li>
<li>导出字段名字不考虑大小写与 &ldquo;Name&rdquo; 匹配的</li>
</ul>
<p>如果找不到匹配的，也就是 JSON数据中的某些键，在结构体中并不存在，则会忽略这些键。比如下面这个例子，将会忽略 love 字段：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">b2</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#e6db74">`{&#34;Name&#34;:&#34;bob&#34;,&#34;love&#34;:&#34;coding&#34;,&#34;Age&#34;:21}`</span>)
<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p3</span> <span style="color:#a6e22e">People</span>
<span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">b2</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p3</span>)
</code></pre></div><p>但是还有一个问题，就是如果你不知道结构体的具体类型怎么办？</p>
<h2 id="空接口类型">空接口类型</h2>
<p>空接口类型 interface{} 就是一个有零个方法的接口，每一个基本类型都实现了至少 0 个接口，因此每个类型都满足空接口。</p>
<p>空接口可以作为一个通用的容器类型，来存储各种类型的数据：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}
<span style="color:#a6e22e">i</span> = <span style="color:#e6db74">&#34;bob&#34;</span>
<span style="color:#a6e22e">i</span> = <span style="color:#ae81ff">88</span>
<span style="color:#a6e22e">i</span> = <span style="color:#ae81ff">3.14</span>
</code></pre></div><p>通过类型断言，我们可以得到底层具体类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">r</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">string</span>) <span style="color:#75715e">// r 是 string类型
</span></code></pre></div><p>但是，如果我们连底层的具体类型都不知道还怎么断言呢？别慌，我们可以通过 switch 来判断具体类型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#66d9ef">type</span>) {
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">int</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;string&#34;</span>,<span style="color:#a6e22e">t</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">string</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;string&#34;</span>,<span style="color:#a6e22e">t</span>)
	<span style="color:#66d9ef">default</span>:
}
</code></pre></div><p>json 包使用了 map[string]interface{} 和 []interface{} 存储任意的 JSON 对象和数组，所以我们可以解析任意的 JSON 数据到一个 空接口 interface{} 类型的值，基本类型对应关系：</p>
<ul>
<li>JSON bool -&gt; bool</li>
<li>JSON numbers -&gt; float64</li>
<li>JSON string -&gt; string</li>
<li>JSON null -&gt; nil</li>
</ul>
<h2 id="解码任意json数据">解码任意JSON数据</h2>
<p>先定义一个JSON数据：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">b</span><span style="color:#f92672">:=</span>[]byte(<span style="color:#e6db74">`{&#34;Name&#34;:&#34;bob&#34;,&#34;love&#34;:&#34;coding&#34;,&#34;Age&#34;:21}`</span>)
</code></pre></div><p>假设我们不知道该数据的结构，我们可以先把它解析到空接口值里：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">interface</span>{} <span style="color:#75715e">//此处也可以替换为 map[string]interface{} 类型
</span><span style="color:#75715e"></span><span style="color:#a6e22e">err</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">b</span>,<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">f</span>)
</code></pre></div><p>此时，f 的值就是一个 map，等价于下面的值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{}{
<span style="color:#e6db74">&#34;Name&#34;</span>:<span style="color:#e6db74">&#34;bob&#34;</span>,
<span style="color:#e6db74">&#34;Age&#34;</span>:<span style="color:#ae81ff">21</span>,
<span style="color:#e6db74">&#34;love&#34;</span>:<span style="color:#e6db74">&#34;coding&#34;</span>,
}
</code></pre></div><p>现在我们知道 f 的底层类型为 map[string]interface{}，我们就可以通过断言来获取具体的数据了：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">m</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">f</span>.(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">interface</span>{})
<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span><span style="color:#f92672">:=</span><span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span>{
	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">vv</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">v</span>.(<span style="color:#66d9ef">type</span>){
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">string</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;k&#34;</span>,<span style="color:#a6e22e">k</span>,<span style="color:#e6db74">&#34;string&#34;</span>,<span style="color:#a6e22e">vv</span>)
		<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">int</span>:
		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;k&#34;</span>,<span style="color:#a6e22e">k</span>,<span style="color:#e6db74">&#34;int&#34;</span>,<span style="color:#a6e22e">vv</span>)
    }
}
</code></pre></div>
    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js//highlight.min.js"></script>



<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-166290945-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

