<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.71.0-DEV" />


<title>HD Wallet 原理与分析 - 大远的博客</title>
<meta property="og:title" content="HD Wallet 原理与分析 - 大远的博客">


  <link href='http://www.tpkeep.com/favicon.jpg' rel='icon' type='image/x-icon'/>



  










<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/%3cnil%3e"
         width=""
         height=""
         alt="">
  </a>

  <ul class="nav-links">
    
    <li><a href="/">首页</a></li>
    
    <li><a href="/post">归档</a></li>
    
    <li><a href="/tags">标签</a></li>
    
    <li><a href="/categories">分类</a></li>
    
    <li><a href="/about">关于</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">5 min read</span>
    

    <h1 class="article-title">HD Wallet 原理与分析</h1>

    
    <span class="article-date">2019-10-30</span>
    

    <div class="article-content">
      <h2 id="概述">概述</h2>
<p>分层确定性钱包，可以从一个种子派生出一系列密钥对用于生成地址，便于钱包的备份与管理</p>
<p><strong>助记词、种子、公钥、地址之间的关系：</strong></p>
<p><em>助记词与种子公钥与地址之间只能单向推导</em>
<img src="/image/hdwallet.png" alt="hdwallet.png"></p>
<p><strong>涉及到的 BIP 协议：</strong></p>
<ol>
<li>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39</a> 定义助记词的生成规则和助记词到种子的推导规则</p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a> hd 钱包核心提案，定义分层概念和算法</p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a> 定义 5 层路径规则</p>
</li>
<li>
<p><a href="https://github.com/bitcoin/bips/blob/master/bip-0045.mediawiki">BIP45</a> 定义多签地址生成规则</p>
</li>
</ol>
<p>本篇文章，我将对上述协议分别展开讨论与分析，并且在最后会通过代码示例来帮助我们更好的理解协议的内容。</p>
<h2 id="bip39">BIP39</h2>
<p>此处查看 <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP39 文档</a></p>
<p>文档概要：</p>
<ul>
<li>定义了助记词的生成规则</li>
<li>定义了助记词到种子的转换规则</li>
<li>定义了助记词 wordlist，目前包含7种语言，每种 2048个单词</li>
<li>助记词到种子的推导是单向的</li>
</ul>
<p><strong>助记词的生成：</strong></p>
<ol>
<li>产生一个随机数作为熵 entropy，长度为 128-256 bits，必须为 32 bits 的整数倍。</li>
<li>然后在 entropy 尾部追加校验 checksum，checksum 是取 entropy 的 sha256 哈希值的前 n 位，位数跟 entropy 的长度有关，具体如下：</li>
</ol>
<table>
<thead>
<tr>
<th>entropy</th>
<th>checksum</th>
<th>entropy+checksum</th>
<th>mnemonic</th>
</tr>
</thead>
<tbody>
<tr>
<td>128</td>
<td>4</td>
<td>132</td>
<td>12</td>
</tr>
<tr>
<td>160</td>
<td>5</td>
<td>165</td>
<td>15</td>
</tr>
<tr>
<td>192</td>
<td>6</td>
<td>198</td>
<td>18</td>
</tr>
<tr>
<td>224</td>
<td>7</td>
<td>231</td>
<td>21</td>
</tr>
<tr>
<td>256</td>
<td>8</td>
<td>264</td>
<td>24</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>然后 将 entropy+checksum 进行分组，每组 11 bits，每组的取值范围是  0 ~ 2047，刚好映射 wordlist 里的单词。</li>
<li>将映射的单词以空格隔开拼接为字符串，即为助记词。</li>
</ol>
<p><strong>助记词到种子的推导：</strong></p>
<p>通过 PBKDF2 函数生成大小为 64 byte 的种子。</p>
<p>PBKDF2（Password-Based Key Derivation Function 2）是一个基于口令的密钥推导方法，用于增强弱秘钥的安全性。本质上就是基于 hash 函数通过加盐和迭代因子让处理速度变慢，减少爆破风险。具体可参考 <a href="https://en.wikipedia.org/wiki/PBKDF2">wiki</a></p>
<p>该函数定义如下：</p>
<p>DK = PBKDF2(PRF, Password, Salt, c, dkLen)</p>
<p>其中 ：</p>
<ul>
<li>PRF 为伪随机函数相当于一个 hash 函数</li>
<li>Password 是口令，由用户负责安全</li>
<li>Salt 是盐，用于增加破解难度</li>
<li>c 是迭代次数，越大越安全</li>
<li>dkLen 是产生的密钥长度</li>
</ul>
<p>在 bip39 中，用于产生种子的上述参数分别为：</p>
<ul>
<li>HMAC-SHA512 单向的 hash 算法</li>
<li>助记词字符串</li>
<li>“mnemonic&quot;+passphrase（口令是可选的）</li>
<li>2048</li>
<li>512（bits）</li>
</ul>
<p>由函数 PBKDF2 可知，<strong>助记词到种子的推导是单向的不可逆的。</strong></p>
<p><strong>代码参考：</strong><a href="https://github.com/tpkeeper/addrtool">https://github.com/tpkeeper/addrtool</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestGenMnemonic</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
	<span style="color:#75715e">//生成熵
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">entropyBytes</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">bip39</span>.<span style="color:#a6e22e">NewEntropy</span>(<span style="color:#ae81ff">128</span>)
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#e6db74">&#34;entropyBytes：&#34;</span>,<span style="color:#a6e22e">entropyBytes</span>)

	<span style="color:#75715e">//生成助记词
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">mnemonic</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">bip39</span>.<span style="color:#a6e22e">NewMnemonic</span>(<span style="color:#a6e22e">entropyBytes</span>)
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#e6db74">&#34;mnemonic：&#34;</span>,<span style="color:#a6e22e">mnemonic</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestMnemonicToSeed</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
	<span style="color:#a6e22e">mnemonic</span> <span style="color:#f92672">:=</span><span style="color:#e6db74">&#34;chef fiction deputy stage pudding pink skirt often decade drift music loop&#34;</span>
	<span style="color:#75715e">//助记词生成种子 password 为空
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">seed</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">bip39</span>.<span style="color:#a6e22e">NewSeed</span>(<span style="color:#a6e22e">mnemonic</span>,<span style="color:#e6db74">&#34;&#34;</span>)
	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#e6db74">&#34;seed：&#34;</span>,<span style="color:#a6e22e">hex</span>.<span style="color:#a6e22e">EncodeToString</span>(<span style="color:#a6e22e">seed</span>))
}

<span style="color:#75715e">//output:
</span><span style="color:#75715e">//entropyBytes： [158 45 139 248 16 245 71 178 223 231 241 118 0 211 244 134]
</span><span style="color:#75715e">//mnemonic： owner hobby wrap capable federal sunny legend wreck invite alley wood aspect
</span><span style="color:#75715e">//seed： 04ef53d66b17fdfb6538c5d183f0b0569fc1c79d07f044f7670c3038aff411e5abcbe8c457b584d0c1e3504ab94fb311f9097a793c20dfc746a87087ed5dc119
</span></code></pre></div><h2 id="bip32">BIP32</h2>
<p>查看文档 <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a></p>
<p>概要：</p>
<ul>
<li>定义了由种子推导树状扩展密钥对的算法与规则</li>
</ul>
<p>基本概念：</p>
<ul>
<li>扩展秘钥有两种，扩展私钥和扩展公钥，扩展私钥可以扩展子私钥，扩展公钥可以扩展子公钥</li>
<li>扩展私钥定义为：(k , c)，其中 k 为私钥，c 为 链码 chaincode</li>
<li>扩展公钥定义为：(K , c)，其中 K 为公钥，c 为 链码 chaincode</li>
<li>子秘钥扩展方法定义为：CKD(extended key , index），其中参数为扩展秘钥和索引。</li>
</ul>
<p>需要注意：</p>
<ul>
<li>扩展为非强化子秘钥时 index 范围为: 0 ~ ($2^{31}-1$)，扩展为强化子秘钥时 index 范围为: $2^{31}$ ~ $(2^{32}-1)$</li>
<li>只有扩展私钥才能扩展强化子扩展秘钥</li>
</ul>
<p>扩展的具体过程：</p>
<ol>
<li>首先计算主扩展秘钥，即树根对应的扩展秘钥。
计算 HMAC-SHA512(&ldquo;Bitcoin seed&rdquo; , seed) 得到 512 bits，其中参数 seed 是在 BIP32 中生成的种子。然后将结果分为 L 和 R，各占 32 字节，分别作为主扩展秘钥的私钥和链码，得到主扩展秘钥。</li>
<li>然后通过 CKD(extended key , index) 方法向下层层扩展子密钥。</li>
</ol>
<p>CKD()方法扩展子秘钥有如下场景：</p>
<ol>
<li>父扩展私钥 -&gt; 强化子扩展私钥</li>
<li>父扩展私钥 -&gt; 非强化子扩展私钥</li>
<li>父扩展公钥 -&gt; 非强化子扩展公钥</li>
<li>父扩展公钥 -&gt; 强化子扩展公钥(不允许)</li>
</ol>
<p><img src="/image/ckd.png" alt="ckd.png"></p>
<p>有上图可知，场景 3，可以在不生成私钥的情况下，通过公钥扩展子公钥。这些公钥对应的私钥正好需要通过场景 2 来额外生成。具体的原理用到了椭圆曲线加密算法 ECC 的运算特性。途中的 <code>||</code> 是字节拼接操作，<code>+</code> 和 <code>x</code> 都是 ECC 里的运算。在 ECC 中有以下定义：</p>
<p>key x G = pubKey</p>
<p>(key1 + key2) x G = pubKey1 + pubkey2</p>
<p>现在我们来证明 childPrivKey 就是 childPubKey 的私钥：</p>
<p>已知：</p>
<p>上图中场景 2 和场景 3，推导出的 il 是同一个值</p>
<p>il + parentPrivKey = childPrivKey</p>
<p>il x G + parentPubKey = childPubKey</p>
<p>我们可以得出：</p>
<p>il x G + parentPrivKey x G = childPrivKey x G</p>
<p>parentPrivKey x G = parentPubKey</p>
<p>进而得出：</p>
<p>il x G + parentPubkey = childPrivKey x G = childPubKey</p>
<p>所以 childPrivKey 就是 childPubkey 对应的私钥</p>
<p><strong>代码参考:</strong> <a href="https://github.com/tpkeeper/addrtool">https://github.com/tpkeeper/addrtool/</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">TestSeedToPubkey</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">testing</span>.<span style="color:#a6e22e">T</span>) {
	<span style="color:#a6e22e">seed</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;04ef53d66b17fdfb6538c5d183f0b0569fc1c79d07f044f7670c3038aff411e5abcbe8c457b584d0c1e3504ab94fb311f9097a793c20dfc746a87087ed5dc119&#34;</span>
	<span style="color:#a6e22e">hexByte</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">hex</span>.<span style="color:#a6e22e">DecodeString</span>(<span style="color:#a6e22e">seed</span>)
	<span style="color:#75715e">//m
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">masterExtKey</span>, <span style="color:#a6e22e">_</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">bip32</span>.<span style="color:#a6e22e">NewMasterKey</span>(<span style="color:#a6e22e">hexByte</span>)
	<span style="color:#75715e">//m/purpose&#39;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">purposeExtKey</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">masterExtKey</span>.<span style="color:#a6e22e">NewChildKey</span>(<span style="color:#a6e22e">bip32</span>.<span style="color:#a6e22e">FirstHardenedChild</span><span style="color:#f92672">+</span><span style="color:#ae81ff">44</span>)
	<span style="color:#75715e">//m/purpose&#39;/cointype&#39;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">coinTypeExtKey</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">purposeExtKey</span>.<span style="color:#a6e22e">NewChildKey</span>(<span style="color:#a6e22e">bip32</span>.<span style="color:#a6e22e">FirstHardenedChild</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0</span>)
	<span style="color:#75715e">//m/purpose&#39;/cointype&#39;/account&#39;
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">accountExtKey</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">coinTypeExtKey</span>.<span style="color:#a6e22e">NewChildKey</span>(<span style="color:#a6e22e">bip32</span>.<span style="color:#a6e22e">FirstHardenedChild</span><span style="color:#f92672">+</span><span style="color:#ae81ff">0</span>)
	<span style="color:#75715e">//m/purpose&#39;/cointype&#39;/account&#39;/change
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">changeExtKey</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">accountExtKey</span>.<span style="color:#a6e22e">NewChildKey</span>(<span style="color:#ae81ff">0</span>)
	<span style="color:#75715e">//m/purpose&#39;/cointype&#39;/account&#39;/change/addrIndex
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">addrIndex0ExtKey</span>,<span style="color:#a6e22e">_</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">changeExtKey</span>.<span style="color:#a6e22e">NewChildKey</span>(<span style="color:#ae81ff">0</span>)
	<span style="color:#75715e">//pubkey
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">Log</span>(<span style="color:#a6e22e">hex</span>.<span style="color:#a6e22e">EncodeToString</span>(<span style="color:#a6e22e">addrIndex0ExtKey</span>.<span style="color:#a6e22e">PublicKey</span>().<span style="color:#a6e22e">Key</span>))
}
</code></pre></div><h2 id="bip44">BIP44</h2>
<p>查看文档：<a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki">BIP44</a></p>
<p>概要：</p>
<ul>
<li>定义了5层路径规则，可兼容多账号多币种</li>
</ul>
<p><strong>bip44 协议的 5 层路径规则：</strong></p>
<p><em>路径：m/purpse’/coin_type’/account’/change/address_index（符号 ‘ 表示强化子秘钥，需要 index &gt;= $2^{31}$）</em></p>
<ul>
<li>m：主扩展密钥</li>
<li>purpose： bip44/bip45</li>
<li>coin_type： 币种</li>
<li>account： 钱包账户</li>
<li>change： 0 对外 / 1 找零</li>
<li>address_index： 地址索引</li>
</ul>
<p>每一层对应的关系如下：</p>
<p><img src="/image/bip44.png" alt="bip44.png"></p>
<h2 id="拿到公钥">拿到公钥</h2>
<p>生成公钥：</p>
<p>通过层层扩展，拿到第五层的扩展密钥 (k,c)，其中的 k 即为 privkey,然后结合椭圆曲线的算法即可得到 pubKey</p>
<h2 id="公钥到地址的转换">公钥到地址的转换</h2>
<p>简单的理解，地址就是 公钥或者脚本 的哈希值的 base58 格式。</p>
<p><strong>常用的地址的格式：</strong></p>
<p><strong>P2PKH</strong> (Pay To PubKey Hash) 格式的地址</p>
<p><img src="/image/p2pkh_addr.png" alt="p2pkh_addr.png"></p>
<p><strong>P2SH</strong> (Pay To Script Hash) 格式的地址</p>
<p><img src="/image/p2sh_addr.png" alt="p2sh_addr.png"></p>
<p>前缀占用一个字节，表示地址类型。</p>
<p>hash160(pubkey) 占用 20 字节。</p>
<p>校验位占用 4 个字节，是对 <strong>前缀 + hash160(pubkey)</strong> 进行两次 sha256 取前四个字节。</p>
<p>使用 base58 便于更友好的显示，增加的校验还可以防止用户输入错误，bip32 中也是这种格式来显示扩展密钥。</p>
<p><strong>代码参考：</strong><a href="https://github.com/tpkeeper/addrtool">https://github.com/tpkeeper/addrtool</a></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-golang" data-lang="golang"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">PubkeyToAddress</span>(<span style="color:#a6e22e">key</span> []<span style="color:#66d9ef">byte</span>,<span style="color:#a6e22e">netId</span> <span style="color:#66d9ef">byte</span>)(<span style="color:#66d9ef">string</span>){
	<span style="color:#a6e22e">hash160Bytes</span><span style="color:#f92672">:=</span><span style="color:#a6e22e">btcutil</span>.<span style="color:#a6e22e">Hash160</span>(<span style="color:#a6e22e">key</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">base58</span>.<span style="color:#a6e22e">CheckEncode</span>(<span style="color:#a6e22e">hash160Bytes</span>,<span style="color:#a6e22e">netId</span>)
}
</code></pre></div><p>base58前缀目录一览:</p>
<p><em>其中 xpub xprv 就是 BIP32 中的扩展公/私密钥的 base58 导出格式</em></p>
<p><img src="/image/base58pre.png" alt="base58pre.png"></p>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js//highlight.min.js"></script>



<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-166290945-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

