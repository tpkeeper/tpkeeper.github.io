<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.71.0-DEV" />


<title>密码学系列：签名 - 大远的博客</title>
<meta property="og:title" content="密码学系列：签名 - 大远的博客">


  <link href='http://www.tpkeep.com/favicon.jpg' rel='icon' type='image/x-icon'/>



  










<link rel="stylesheet" href="/css/fonts.css" media="all">
<link rel="stylesheet" href="/css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="/" class="nav-logo">
    <img src="/images/%3cnil%3e"
         width=""
         height=""
         alt="">
  </a>

  <ul class="nav-links">
    
    <li><a href="/">首页</a></li>
    
    <li><a href="/post">归档</a></li>
    
    <li><a href="/tags">标签</a></li>
    
    <li><a href="/categories">分类</a></li>
    
    <li><a href="/about">关于</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">3 min read</span>
    

    <h1 class="article-title">密码学系列：签名</h1>

    
    <span class="article-date">2019-09-11</span>
    

    <div class="article-content">
      <p>签名是用于消息的认证，保证该条消息不被伪造。本文主要讨论RSA签名、DSA、ECDSA 和 Schnorr  签名算法。</p>
<h2 id="rsa签名">RSA签名</h2>
<p>安全性建立在大数分解问题</p>
<p>公钥：E、N
私钥：D、N
签名：签名 = 消息^D mod N
验证：消息&rsquo; = 签名^E mod N ，如果消息'==消息则验证成功</p>
<h2 id="dsa">DSA</h2>
<p>由NIST(美国国家标准技术研究所)1991年制定的数字签名技术规范，是Schnorr算法的变体。</p>
<p>安全性建立在离散对数问题</p>
<p>密钥生成(1024bits)：</p>
<ol>
<li>生成素数 p，$2^{1023} &lt; p &lt; 2^{1024}$</li>
<li>找到 p-1 的一个素数 q，且 $2^{159} &lt; q &lt; 2^{160}$</li>
<li>找到 ord(a)=q 的元素 a，a 生成了拥有 q 个元素的子群</li>
<li>生成随机数，0 &lt; d &lt; q</li>
<li>b = $a^d$ mod p</li>
<li>则密钥对为：$k_{pub}$ = (p,q,a,b)，$k_{pri}$ = (d)</li>
</ol>
<p>签名生成：</p>
<ol>
<li>随机生成一个整数最为随机的临时密钥 $k_E$，且满足 0 &lt; $k_E$ &lt; q。</li>
<li>计算 r = ($a^{k_E}$ mod p) mod q</li>
<li>计算 s = (SHA(x)+d * r)$k_E^{-1}$ mod q</li>
</ol>
<p>签名的验证：</p>
<ol>
<li>计算辅助值 w = $s^{-1}$ mod q</li>
<li>计算辅助值 $u_1$ = w * SHA(x) mod q</li>
<li>计算辅助值 $u_2$ = w * r mod q</li>
<li>v = ($a^{u_1} * b^{u_2}$ mod p) mod q</li>
<li>v&rsquo; = r mod q，如果 v == v&rsquo; 则签名正确</li>
</ol>
<p>Golang SDK dsa 签名过程代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">attempts</span> = <span style="color:#ae81ff">10</span>; <span style="color:#a6e22e">attempts</span> &gt; <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">attempts</span><span style="color:#f92672">--</span> {
		<span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">big</span>.<span style="color:#a6e22e">Int</span>)
		<span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">n</span>)
		<span style="color:#66d9ef">for</span> {
			<span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ReadFull</span>(<span style="color:#a6e22e">rand</span>, <span style="color:#a6e22e">buf</span>)
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#66d9ef">return</span>
			}
            <span style="color:#75715e">//生成随机数密钥
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">k</span>.<span style="color:#a6e22e">SetBytes</span>(<span style="color:#a6e22e">buf</span>)
			<span style="color:#75715e">// priv.Q must be &gt;= 128 because the test above
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// requires it to be &gt; 0 and that
</span><span style="color:#75715e"></span>			<span style="color:#75715e">//    ceil(log_2(Q)) mod 8 = 0
</span><span style="color:#75715e"></span>			<span style="color:#75715e">// Thus this loop will quickly terminate.
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span>.<span style="color:#a6e22e">Sign</span>() &gt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">k</span>.<span style="color:#a6e22e">Cmp</span>(<span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">Q</span>) &lt; <span style="color:#ae81ff">0</span> {
				<span style="color:#66d9ef">break</span>
			}
		}

        <span style="color:#75715e">//求密钥的逆
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">kInv</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fermatInverse</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">Q</span>)

        <span style="color:#75715e">//计算 r
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">r</span> = new(<span style="color:#a6e22e">big</span>.<span style="color:#a6e22e">Int</span>).<span style="color:#a6e22e">Exp</span>(<span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">G</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">P</span>)
		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Mod</span>(<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">Q</span>)

		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Sign</span>() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#66d9ef">continue</span>
		}

		<span style="color:#a6e22e">z</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">k</span>.<span style="color:#a6e22e">SetBytes</span>(<span style="color:#a6e22e">hash</span>)

        <span style="color:#75715e">//计算s
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">s</span> = new(<span style="color:#a6e22e">big</span>.<span style="color:#a6e22e">Int</span>).<span style="color:#a6e22e">Mul</span>(<span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">X</span>, <span style="color:#a6e22e">r</span>)
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">z</span>)
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Mod</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">Q</span>)
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Mul</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">kInv</span>)
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Mod</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">Q</span>)

		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Sign</span>() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#66d9ef">break</span>
		}
	}
</code></pre></div><h2 id="ecdsa">ECDSA</h2>
<p>安全性建立在基于椭圆曲线的离散对数问题</p>
<p>密钥的生成：</p>
<ol>
<li>
<p>使用曲线 E</p>
<ul>
<li>模数为 p</li>
<li>系数为 a 和 b</li>
<li>生成元为 G，G 生成的循环群的阶(即元素的个数)为 n</li>
</ul>
</li>
<li>
<p>选择一个随机数 d，0 &lt; d &lt; n</p>
</li>
<li>
<p>计算 K = dG</p>
</li>
<li>
<p>密钥对则为：$k_{pub}$ = (K)，$k_{pri}$ = (d)</p>
</li>
</ol>
<p>签名的生成(x 为消息)：</p>
<ol>
<li>随机生成一个整数最为临时密钥 $k_E$，且 0 &lt; $k_E$ &lt; q。</li>
<li>$R_{(x_R,y_R)}$ = $k_E$G</li>
<li>r = $x_R$ mod n</li>
<li>s = (hash(x)+d * r)$k_E^{-1}$ mod n</li>
</ol>
<p>签名的验证：</p>
<ol>
<li>计算辅助值 w = $s^{-1}$ mod n</li>
<li>计算辅助值 $u_1$ = w * hash(x) mod n</li>
<li>计算辅助值 $u_2$ = w * r mod n</li>
<li>$P_(x_P,y_P)$ = $u_1$G + $u_2$K</li>
<li>如果 $x_P$ == r mod n，则签名有效</li>
</ol>
<p>Golang SDK ecdsa 签名过程代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">for</span> {
		<span style="color:#66d9ef">for</span> {
			<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">randFieldElement</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">csprng</span>)  <span style="color:#75715e">//生成临时密钥
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
				<span style="color:#a6e22e">r</span> = <span style="color:#66d9ef">nil</span>
				<span style="color:#66d9ef">return</span>
			}

            <span style="color:#75715e">//计算 k的逆
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">in</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">Curve</span>.(<span style="color:#a6e22e">invertible</span>); <span style="color:#a6e22e">ok</span> {
				<span style="color:#a6e22e">kInv</span> = <span style="color:#a6e22e">in</span>.<span style="color:#a6e22e">Inverse</span>(<span style="color:#a6e22e">k</span>)
			} <span style="color:#66d9ef">else</span> {
				<span style="color:#a6e22e">kInv</span> = <span style="color:#a6e22e">fermatInverse</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">N</span>) <span style="color:#75715e">// N != 0
</span><span style="color:#75715e"></span>			}

            <span style="color:#75715e">//计算 r
</span><span style="color:#75715e"></span>			<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">Curve</span>.<span style="color:#a6e22e">ScalarBaseMult</span>(<span style="color:#a6e22e">k</span>.<span style="color:#a6e22e">Bytes</span>())
			<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Mod</span>(<span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">N</span>)
			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Sign</span>() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
				<span style="color:#66d9ef">break</span>
			}
		}

		<span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">hashToInt</span>(<span style="color:#a6e22e">hash</span>, <span style="color:#a6e22e">c</span>)
        <span style="color:#75715e">//计算 s
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">s</span> = new(<span style="color:#a6e22e">big</span>.<span style="color:#a6e22e">Int</span>).<span style="color:#a6e22e">Mul</span>(<span style="color:#a6e22e">priv</span>.<span style="color:#a6e22e">D</span>, <span style="color:#a6e22e">r</span>)
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">e</span>)
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Mul</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">kInv</span>)
		<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Mod</span>(<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">N</span>) <span style="color:#75715e">// N != 0
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Sign</span>() <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#66d9ef">break</span>
		}
	}
</code></pre></div><p><strong>pubkey recovery：</strong></p>
<p>从签名信息中恢复公钥</p>
<p>比特币跟以太坊都有实现，但最终的签名信息序列化格式不同</p>
<blockquote>
<p>// btc 中的格式
&lt;(byte of 27+public key solution)+4 if compressed &gt;&lt; padded bytes for 
signature R&gt;<!-- raw HTML omitted --></p>
</blockquote>
<blockquote>
<p>// 以太坊中的格式
[R || S || V] format where V is 0 or 1.</p>
</blockquote>
<p>以太坊中的 go 实现也引用了btcd的代码，所以需要转换一下，具体可参考以太坊代码signature_nocgo.go</p>
<p>另：btc签名脚本中同时含有签名和公钥</p>
<p><strong>公钥长度：</strong></p>
<ul>
<li>compressed： 65 byte （1+32+32）</li>
<li>uncompressed： 33 byte （1+32 ）</li>
</ul>
<h2 id="schnorr">Schnorr</h2>

    </div>
  </article>

  


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="/index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
          <li>
            <a href="https://gohugo.io/" class="footer-links-kudos">Made with <img src="/images/hugo-logo.png" alt="Img link to Hugo website" width="22" height="22"></a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js//highlight.min.js"></script>



<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-166290945-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

