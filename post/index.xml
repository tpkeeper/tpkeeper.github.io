<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 大远的思维时空</title>
    <link>http://www.tpkeep.com/post/</link>
    <description>Recent content in Posts on 大远的思维时空</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 02 Sep 2019 17:04:19 +0800</lastBuildDate>
    
	<atom:link href="http://www.tpkeep.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>加密与解密系列：概述</title>
      <link>http://www.tpkeep.com/blog/encryption-overview/</link>
      <pubDate>Mon, 02 Sep 2019 17:04:19 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/encryption-overview/</guid>
      <description>根据密钥的类型一般可以分为对称加密和非对称加密，而同一类型又有不同的算法实现，本系列文章将对这两种类型的涉及到的加密算法分别分析，并在最后给出参考代码，便于进一步理解。
 对称加密算法  DES（Data Encryption Standard） 三重DES（triple-DES） AES（Advanced Encryption Standard）Rijndael  上边三种算法都只能加密固定长度的一个字节分组，故也可以叫做分组密码。如果要加密大段明文，还需要对明文迭代进行加密，不同的迭代方式就称为模式，主要有以下几种：</description>
    </item>
    
    <item>
      <title>HD Wallet 系列：公钥与地址</title>
      <link>http://www.tpkeep.com/blog/hd-wallet-pubkeytoaddr/</link>
      <pubDate>Sun, 01 Sep 2019 17:04:19 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/hd-wallet-pubkeytoaddr/</guid>
      <description>简单的理解，地址就是公钥/脚本哈希值的base58格式
 一、地址的格式  P2PKH (Pay To PubKey Hash) 格式的地址   P2SH (Pay To Script Hash) 格式的地址  前缀占用一个字节，表示不同的网络 校验占用4个字节 使用base58可以更友好的显示，增加的校验还可以防止用户输入错误，bip32中也是这种格式来显示扩展密钥</description>
    </item>
    
    <item>
      <title>HD Wallet 系列：种子与公钥</title>
      <link>http://www.tpkeep.com/blog/hd-wallet-seedtopubkey/</link>
      <pubDate>Sun, 01 Sep 2019 17:04:19 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/hd-wallet-seedtopubkey/</guid>
      <description>参考 bip32、bip44
  定义了种子生成树状密钥对的算法与规则 定义了5层路径规则，可兼容多账号多币种  一、密钥扩展算法 1.</description>
    </item>
    
    <item>
      <title>HD Wallet 系列：助记词与种子</title>
      <link>http://www.tpkeep.com/blog/hd-wallet-mnemonic/</link>
      <pubDate>Sat, 31 Aug 2019 17:04:19 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/hd-wallet-mnemonic/</guid>
      <description>参考 bip39
  定义了助记词的生成规则 定义了由助记词导出种子的规则 定义了助记词 wordlist，目前包含7种语言，每种 2048个单词 助记词到种子的推导是单向的  一、助记词的生成  产生一个随机数作为熵 entropy，长度为 128-256 bits，必须为 32 bits 的整数倍 然后在 entropy 尾部 append 校验位，校验位即entropy 的 sha256 的前几位，位数如下：     entropy checksum entropy+checksum mnemonic     128 4 132 12   160 5 165 15   192 6 198 18   224 7 231 21   256 8 264 24     然后 将 entropy+checksum 按 11 bits 分组，每组 11bits，大小为 0 ~ 2^11-1 即 0 ~ 2047，刚好映射 wordlist 里的单词 单词以空格隔开转换为字符串  二、助记词生成种子  准备： 参数 1 作为密码：助记词字符串 参数 2 作为盐：&amp;rdquo;mnemonic&amp;rdquo;+passphrase（可选的）， 参数 3 作为循环次数： 2048 ， 参数 4 作为 hash 函数：HMAC-SHA512 参数 5 作为派生key长度：512bits</description>
    </item>
    
    <item>
      <title>HD Wallet 系列：概述</title>
      <link>http://www.tpkeep.com/blog/hd-wallet-overview/</link>
      <pubDate>Sat, 31 Aug 2019 17:04:19 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/hd-wallet-overview/</guid>
      <description>分层确定性钱包，可以从一个种子派生出一系列密钥对用于生成地址，便于钱包的备份与管理
 助记词、种子、公钥、地址之间的关系如下：
 助记词与种子公钥与地址之间只能单向推导  主要涉及到的bip协议：
 bip32 hd 钱包核心提案，定义分层概念和算法</description>
    </item>
    
    <item>
      <title>btcd 源码分析系列：7 - rpc</title>
      <link>http://www.tpkeep.com/blog/btcd-src-rpc/</link>
      <pubDate>Fri, 30 Aug 2019 17:04:40 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/btcd-src-rpc/</guid>
      <description>参考：btcd
  btcd实现了基于http的和websocket的json-rpc,支持http Basic authentication。 websocket通道 支持所有的请求类型，http通道不支持通知类（notify）的请求 http/websocket是传输协议，json是序列化协议。  一、start  启动一个server,监听路径&amp;rdquo;/&amp;ldquo;和&amp;rdquo;/ws&amp;rdquo;,分别对应http/websocket。 通过chedkAuth()函数认证，基于Basic authentication 通过limitConnections（）对单个地址的并发连接数量做限制</description>
    </item>
    
    <item>
      <title>btcd 源码分析系列：6 - mempool</title>
      <link>http://www.tpkeep.com/blog/btcd-src-mempool/</link>
      <pubDate>Fri, 30 Aug 2019 17:04:31 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/btcd-src-mempool/</guid>
      <description>参考：btcd
  btcd提供了一个内存池mempool，用于存储还未被矿工打包的交易。 utxo和block index存储于leveldb中，而不是本文讨论的mempool 被插入之前要进行一系列的正确性验证（通过mabeAcceptTransaction）。 如果是orphan tx（即在main chain和mempool里找不到input的所属交易tx）会暂时插入到orphans pool（通过ProcessTransaction）。 当新的block连接到主链时，会把block中的tx从mempool中移除，相应的也会转移orphans pool中依赖此block的tx到mempool中（通过MabeAcceptTransaction） 当block从主链脱离时，会重新处理block里的tx(通过MabeAcceptTransaction)  一、创建mempool对象  在server被创建的时候调用此方法生成一个mempool对象 可以看到，pool用来存储正常的tx，orphans存储orphan tx</description>
    </item>
    
    <item>
      <title>btcd源码分析系列：5 - p2p网络的消息协议</title>
      <link>http://www.tpkeep.com/blog/btcd-src-wire/</link>
      <pubDate>Fri, 30 Aug 2019 17:04:19 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/btcd-src-wire/</guid>
      <description>参考：protocol document 、btcd
  协议其实就是一个标准，btc有多种语言的实现版本，他们之间能够正常通信的基础就是共同遵守了这个标准。btc定义的协议有很多，包括p2p之间通信协议、交易认证协议、pow共识协议等等。本文主要分析p2p网络的消息协议及代码实现 btc 的p2p网络的传输层支持tcp、udp、onion，应用层使用的即是本文讨论的消息协议  一、Message 一次通信以message为单位，具体结构如上图： 代码实现：</description>
    </item>
    
    <item>
      <title>btcd 源码分析系列：4 - p2p网络的peer</title>
      <link>http://www.tpkeep.com/blog/btcd-src-peer/</link>
      <pubDate>Fri, 30 Aug 2019 17:04:14 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/btcd-src-peer/</guid>
      <description>参考：btcd
  btc在p2p网络中与每一个节点的连接都视为一个peer对象，与该节点的消息交换都是通过该peer进行。本文主要分析peer对象的创建以及wire协议消息的收发机制。对应btcd中package peer，该package主要提供了与其他节点连接建立之后peer的创建，协商，消息处理，以及close功能。  一、创建peer对象 peer具体分为两种： * inbound 当connmanager监听到其他节点的请求时创建 * outbound 当connmanager主动连接其他节点时创建 * 两者在创建时都使用了newPeerBase()函数，但是outbound 增加了对addr和na属性的初始化</description>
    </item>
    
    <item>
      <title>btcd 源码分析系列：3 - connmanager</title>
      <link>http://www.tpkeep.com/blog/btcd-src-connmanager/</link>
      <pubDate>Fri, 30 Aug 2019 17:03:47 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/btcd-src-connmanager/</guid>
      <description>参考：btcd
  connmanamger 负责节点的连接处理，包括监听来自其他节点的连接请求和主动向其他节点发起连接请求，并将获取到的连接对象conn交给回调函数处理，实际上这些回调函数是由server实现的，它们会根据conn生成对应的peer，交由peer处理之后的逻辑 默认outbound peer数量为8 节点发现  address database （第一次启动时为空） -addnode -connect (手动) dns seed （通过dns获取addr） hard-coded seeds（代码中的seed） getaddr from other peers （通过其他节点同步）   一、创建connmanager对象  主要是根据传入的config结构体参数返回一个指针，config结构体主要 包含一些回调方法和[]listener,这样便于灵活实现和调用  // New returns a new connection manager.</description>
    </item>
    
    <item>
      <title>btcd 源码分析系列 - 1 - 启动分析</title>
      <link>http://www.tpkeep.com/blog/btcd-src-start/</link>
      <pubDate>Fri, 30 Aug 2019 13:56:08 +0800</pubDate>
      
      <guid>http://www.tpkeep.com/blog/btcd-src-start/</guid>
      <description>参考：btcd
 主启动顺序 main函数位于btcd.go，此处省略了辅助功能的服务（profile等）
 loadconfig() 加载配置 doUpgrades() 升级操作 loadBlockDB() 加载数据库 server.</description>
    </item>
    
    <item>
      <title>btcd 源码分析系列：2 - addrmanager</title>
      <link>http://www.tpkeep.com/blog/btcd-src-addrmanager/</link>
      <pubDate>Fri, 30 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.tpkeep.com/blog/btcd-src-addrmanager/</guid>
      <description>参考：btcd
  addrmanager 主要提供了peer地址的管理功能，包括地址的增删查改 通过存储json序列化后的数据到本地文件实现持久化 btc启动的时候，会读取该json文件，将保存的节点信息读取到内存中 btc运行的过程中，每过一段时间（十分钟）就持久化一次，以备下次启动时使用 btc退出时，会再次持久化一次  一、创建addrmanager对象 // New returns a new bitcoin address manager.</description>
    </item>
    
  </channel>
</rss>